% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% slovak thesis in Slovak language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=B,czech]{FITthesis}[2012/06/26]

\usepackage[utf8]{inputenc}
\usepackage{float}

% \usepackage[unicode]{hyperref}
\usepackage{listings}
\usepackage{color}


\RequirePackage{pdfpages}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  numbers=left
}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\usepackage{graphicx} %graphics files inclusion
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

\newcommand{\tg}{\mathop{\mathrm{tg}}} %cesky tangens
\newcommand{\cotg}{\mathop{\mathrm{cotg}}} %cesky cotangens


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% ODTUD DAL VSE ZMENTE
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\department{Katedra \ldots (softwarového inženýrství)}
\title{ InfoWeb - Nástroj získávání informací z webů }
\authorGN{Jakub} %(křestní) jméno (jména) autora
\authorFN{Tuček} %příjmení autora
\authorWithDegrees{} %jméno autora včetně současných akademických titulů
\supervisor{Ing. Jiří Hunka}
\acknowledgements{Chtěl bych poděkovat za trpělivost vedoucímu, Ing. Jiřímu Hunkovi.}
\abstractCS{V~několika větách shrňte obsah a přínos této práce v~češtině. Po přečtení abstraktu
by se čtenář měl mít čtenář dost informací pro rozhodnutí, zda chce Vaši práci číst.}
\abstractEN{Sem doplňte ekvivalent abstraktu Vaší práce v~angličtině.}
\placeForDeclarationOfAuthenticity{V~Praze}
\declarationOfAuthenticityOption{4} %volba Prohlášení (číslo 1-6)
\keywordsCS{Nahraďte seznamem klíčových slov v češtině oddělených čárkou.}
\keywordsEN{Nahraďte seznamem klíčových slov v angličtině oddělených čárkou.}

\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\begin{introduction}
V předmětech BI-SP1 a BI-SP2 v prostředí FIT ČVUT byl realizován týmový projekt umožňující získávání informací z webů s primárním zaměřením na potřeby obchodů. Projekt řešil problém automatizace získávání dat z webů, jelikož stávající služby neposkytují veřejné rozhraní
nebo mají velkou chybovost dat.
\par
Práce pojednává o požadavcích internetových obchodů, které jsou především tvořeny nutností držet krok s trhem a sledovat vývoj cen
prodávaných produktů u konkurence.
\par
Cílem této práce je popsat požadavky internetových obchodů, stávající stav získávání informací z webů a možná řešení problematiky. Dále na základě těchto poznatků zhodnotit vytvořené řešení a včetně korektnosti zvolených postupů navrhnout vylepšení. Ty implementovat, řádně vylepšení
otestovat a zhodnotit výsledný stav projektu.


\newpage

\end{introduction}


\chapter{Popis problematiky získávání informací z webů}

V této kapitole se budu nejprve zabývat samotnou problematikou získávání informací 
z webů s důrazem na internetové obchody.
Jelikož je tato problematika již řešena existujícími službami, nejprve existující služby zhodnotím.

\section{Problematika}
Získávání informací z webů je efektivní možnost jak získat databázi informací, které se na internetu vyskytují.
Tato činnost však stojí na problematice data získávat a uchovávat v potřebné struktuře, jelikož 
jinak z dat nejsme schopni vyčíst potřebné informace.
Vzhledem k specificitě dat, které jsou v kontextu činnosti zajímavá a kvůli unikátnosti webových stránek
není možné jednoznačně určit jednotný a zcela automatizovaný postup, jak data získat v požadovaném formátu.

\section{Výběr dat}
Nejčastější řešení je kombinace automatizace a prvku lidské inteligence.
To je obvykle dosaženo roboty, kteří data stahují a lidské práce určující jaké informace nás ve stažených datech zajímají.
\par
Získávání informací ze stažených stránek lze poté zjednodušit na problematiku určení elementů v HTML, které jsou pro 
nás zajímavé.
Lokaci elementu v HTML se kterým je potřeba pracovat, lze poté jednoznačně určit například pomocí těchto dvou možností:
\begin{enumerate}
\item XPath
\item CSS Selector
\end{enumerate}

Možnost jednoznačného určení elementů na stránce pak umožňuje vybrat pouze částí, které jsou v kontextu hledání zajímavé.
Přesná struktura dat, která lze z vybraných dat vytvořit pak může sloužit k dalšímu zpracování.

\section{XML Path Language}
XML Path Language\cite{XPath} nazývaný zkráceně XPath je jazyk, který slouží k výběru elementu v dokumentu ve formátu XML\cite{XML}.
\par
XML chápeme jako jazyk popisující strukturu dat, které jsou strojově i lidsky čitelné.
HTML lze chápat jako strukturu podobnou XML, ačkoliv se přímo o XML dokument nejedná \cite{HTML}. 
HTML popisuje obsah dat pro prezentaci ve webovém prohlížeči pomocí předem definované struktury, které prohlížeče rozumí.
Díky této vlastnosti lze použít XPath pro definování cesty k prvku, který uchovává potřebnou informaci na webové stránce.
\par
\section{CSS Selector}
Jazyk CSS je používán pro vizuální popis prezentace webové stránky definované v HTML. K určení prvků se kterými
pracuje používá selektory, které označují tento prvek v HTML Buď pomocí samotného prvku, přiřazené třídy nebo nastaveného
identifikátoru. Jako selektor může být použit jak samotný název prvku,
tak vlastní definované třídy.\cite{CSS}
\par
Pomocí řetězení těchto selektorů je poté možné jednoznačně získat element v HTML dokumentu.

\newpage

\section{Současný stav řešení potřeb internetových obchodů}
I v kontextu malého trhu jako Česká republika se lze bavit o velké konkurenci na poli 
maloobchodů prodávající své zboží na internetu.
Internetové obchody potřebují monitorovat konkurenci a trh. Vzhledem k jejich zaměření je tedy nejvíce zajímají 
obchody prodávající stejné zboží. Potřebné informace o prodávaných produktů konkurencí 
se skládají z následujících atributů:

\begin{enumerate}
\item Název
\item Model
\item EAN
\item Cena
\item Inzerovaný název
\item Dostupnost
\end{enumerate}

S těmito daty je poté možné dále pracovat, například při analýze konkurence schopnosti na trhu nebo pokud potřebuje
distributor sledovat za jaké ceny jsou prodávané jeho produkty. \cite{hunka}

\subsection{Srovnávače cen}

Data lze získat pomocí srovnávačů cen jako \textit{zbozi.cz}\cite{heureka} 
nebo \textit{heureka.cz}\cite{zbozi}. Problém u těchto služeb spočívá v určení pro koncové zákazníky, kterým umožňuje
nalezení nejlepší ceny na trhu pro hledaný produkt. S tím souvisí to, že největší srovnávače cen neposkytují veřejně 
svá data nebo rozhraní přes která by je bylo možné jednoduše získat. V rámci výzkumu pro bakalářskou práci jsem měl možnost nahlédnout do dat, které \textit{heuréka} poskytuje některým obchodům. \cite{hunka}

Data obsahují následující informace:
\begin{itemize}
\item Informace o produktu - Segment, Kategorie, Jméno, ID, Výrobce, EAN, Item ID
\item Url na vlastním obchodu
\item Url na heuréce
\item Počet konkurence a popularita na trhu
\item Vlastní cena a pozice dle ní
\item Deset nejvyšších a nejnižších cen
\end{itemize}

První zásadní nedostatek zprávy z jmenovaného srovnávače, se ukázal být logistický a to, že obchod musí být označen \uv{Ověřeno zákazníky},
aby měl k datům přístup. Další nedostatek jsou data neobsahující konkrétní označení konkurenčních obchodů.\cite{heureka-report}
Vzhledem k povaze struktury a splatnosti generovaných dat je také nemožné ceny sledovat v časovém období.
Ostatní srovnávače mají údajně výstup velmi podobný, nebo, jak bylo výše řečeno, data neposkytují. Díky tomu se ukázaly
srovnávače jako nedostatečný zdroj dat.\cite{hunka}


\subsection{Existující služby}

Problematiku sledování trhu s důrazem na firemní klientelu, řeší aktuálně několik existujících služeb.
\par
Služby mají v zásadě velmi podobnou povahu poskytovaných možností. Rámcově se jedná o porovnávání cen včetně historie na různých internetových
obchodem či na srovnávačích. Uživatel si zadá okruh či seznam produktů, buďto formou manuální či vstupem ze souboru, případně 
přímých napojením na e-shop. Následně je možné konkrétní data zobrazit v grafech označující vývoj cen, trendů či náhlých změn.
Dále umožňují externí výstup do souboru v dostupných formátech.
\par
Největší rozdíl služeb je zda jsou data získávána přímo z obchodů nebo ze srovnávačů. Další odlišností je 
možnost, zda služba dokáže sledovat i zahraniční trh.
\par
Cena služeb se nejvíce odvíjí od počtu sledovaných produktů a četnosti aktualizací. Proto se měsíční platby mohou 
pohybovat od stovek korun po desítek tisíc korun.

\section{Popis konkrétních existujících služeb}

\subsection{Price checking\cite{priceChecking}} 


\textbf{Hlavní funkce}
\begin{itemize}
\item porovnává a vyhledává ceny zadaných výrobků v reálném čase
\item sleduje dostupnost produktů
\item automatické stahování dat v intervalech
\item statistické pohledy, nahlížení do historie
\item generování grafů
\item cenotvorba
\end{itemize}

\textbf{Vstup}
\begin{itemize}
\item souhrn produktů určený pro sledování
\item libovolný formát, například xsl nebo xml
\item možný manuální vstup
\end{itemize}

\textbf{Výstup}
\begin{itemize}
\item libovolný formát, například xsl nebo xml
\item webové rozhraní
\end{itemize}

\textbf{Prostředí}
\begin{itemize}
\item webové rozhraní
\end{itemize}

\textbf{Data}
\begin{itemize}
\item přes 250 výrobců, 300 obchodů a 1 200 000 výrobků
\item český, slovenský, polský, slovinský, německý a maďarský trh
\item aktualizace denně, maximálně 144 krát za den
\item počet sledovaných obchodů je fixní, lze však přidat na požádání
\item převážně elektronika, bílé zboží, pneumatiky a hračky
\end{itemize}

\textbf{Cena}
\begin{itemize}
\item 6000 - 85 000 Kč (bez dph) za licenci měsíčně
\item minimální doba smlouvy 12 měsíců
\end{itemize}

\begin{figure}[h]\centering
 	\includegraphics[width=0.9\textwidth]{resources/priceChecking}
	\caption[Price checking]{Ukázka služby Price checking}\label{fig:priceChecking}
\end{figure}

\newpage

\subsection{Pricing intelligence\cite{pricingIntelligence}} 

\textbf{Hlavní funkce}
\begin{itemize}
\item monitorování a srovnávání cen konkurence, vývoj cen a trendů v čase
\item přehledné výpisy výsledků
\item u většiny cenových nabídek nutno definovat počet konkurentů
\item upozornění na změny cen v čase
\end{itemize}

\textbf{Výstup}
\begin{itemize}
\item formát xsl nebo pdf
\end{itemize}

\textbf{Prostředí}
\begin{itemize}
\item webové rozhraní
\end{itemize}

\textbf{Data}
\begin{itemize}
\item nespecifikované data a zaměřený trh
\end{itemize}

\textbf{Cena}
\begin{itemize}
\item 599 až 4999 Kč měsíčně
\item minimálně tři měsíce
\item neomezené sledování produktů a konkurentů je možné pouze s nejvyšším tarifem a po individuální ceně
\end{itemize}


\subsection{Sledování trhu\cite{sledovaniTrhu}} 
\textbf{Hlavní funkce}
\begin{itemize}
\item sledování cen, pozic, dostupnosti a hodnocení na porovnávačích zboží i jednotlivých obchodech
\item uchování historie
\item možné napojení přímo na vlastní internetový obchod
\item notifikace změn
\item možnost více účtů s oddělenými přístupy
\item cenotvorba
\item detekce cenových spirál (kdo první zlevnil a následující dopady)
\end{itemize}

\textbf{Vstup}
\begin{itemize}
\item xml, xsl nebo manuálně
\end{itemize}

\textbf{Výstup}
\begin{itemize}
\item xsl nebo webový
\end{itemize}

\textbf{Prostředí}
\begin{itemize}
\item webové rozhraní
\end{itemize}

\textbf{Data}
\begin{itemize}
\item srovnávače cen: heureka.cz, zbozi.cz, najnakup.sk, pricemania.sk, ceneo.pl, nokaut.pl, argep.hu, preisroboter.de
\item přímé sledování na obchodu
\item z toho plyne záběr na český, slovenský, německý a maďarský trh
\item aktualizace až několikrát denně
\end{itemize}

\textbf{Cena}
\begin{itemize}
\item platba za každé vyhledání
\item individuální cena
\end{itemize}

\subsection{Pricebot \cite{priceBot}}

Web je datován roku 2015, avšak popis funkcí není dokončený. Obsahuje výplňový text, proto je popis funkcí nekompletní.

\textbf{Hlavní funkce}
\begin{itemize}
\item denní monitoring cen na heureka.cz
\item možnost sledovat produkty konkurence
\item poskytuje pravidelný výsledek nalezených cen a vizualizaci změn
\item notifikace o změnách
\item notifikace o konkurentech prodávajících za nižší cenu
\item maximum lze sledovat 600 produktů 
\item maximum sledovaných konkurentů je 70
\end{itemize}

\textbf{Vstup}
\begin{itemize}
\item produkty ke sledování
\end{itemize}

\textbf{Výstup}
\begin{itemize}
\item pdf na email
\end{itemize}

\textbf{Prostředí}
\begin{itemize}
\item webové rozhraní
\end{itemize}

\textbf{Data}
\begin{itemize}
\item srovnávač cen Heureka.cz
\end{itemize}

\textbf{Cena}
\begin{itemize}
\item dle počtů produktů
\item od 299 do 1299 Kč
\end{itemize}

\newpage

\subsection{Zahraniční nástroje}
Tyto nástroje jsou obecněji zaměřené a obvykle požadují od uživatele technické znalosti, 
jelikož je nutné přesně specifikovat kde, co a jak je požadováno sledovat. Vzhledem k tomuto omezení, není možné
použití přímo provozovateli e-shopů, jelikož těmito znalostmi z povahy práce obvykle nedisponují.
\par
Příklad zahraničních nástrojů:

\begin{enumerate}
\item Screen scraper \cite{ScreenScraper}

  \begin{itemize}
    \item Webová služba
    \item procházení web skrz odkazy
    \item potvrzování formulářů
    \item využití interního vyhledávání
    \item export do širokého množství formátu souborů
    \item cena: \$549 - \$2,799 za měsíc
  \end{itemize}
  
\item Web extractor \cite{WebExtractor}

  \begin{itemize}
    \item Windows Aplikace
    \item procházení zadaných stránek
    \item hledání stránek pomocí klíčových slov
    \item export do csv formátu
    \item cena: \$99 - \$199 jednorázově
  \end{itemize}


\end{enumerate}

\newpage

\chapter{Analýza týmového projektu}
V této kapitole se budu věnovat řešení vytvořeného v rámci školní výuky na ČVUT FIT v akademickém roce 2015/16.
Popíšu cíl, který měl projekt za úkol řešit a výsledná funkcionalita řešení. Dále také popíši základní strukturu
navrženého řešení.

\section{Cíl týmového projektu}

V předmětech BI-SP1 a BI-SP2 byl realizován týmový projekt, v souladu s osnovami těchto předmětů byl nejdříve v BI-SP1 vytvořen návrh
systému a v BI-SP2 implementován.
\par
Cíl který projekt řešil, byla maximální možná míra automatizace získávání informací o produktech prodávaných konkurencí. Důraz je především kladem na optimalizaci počtu nutných lidských úkonů administrátora u kterého se předpokládá minimální technické vzdělání.
Jediná nutná problematika, co tak musí administrátor ovládat je parsování HTML stránek.
\par

\section{Požadovaná funkcionalita}
Požadovaný stav projektu umožňuje uživateli vložit produkty do systému ve formátu \textit{cvs} či \textit{xlsx}, poté pomocí
rozhraní definovat význam jednotlivých sloupců v tomto dokumentu a zvolit požadovanou frekvenci sledování dat.
\par
Systém na základě dat vyhledá ochody, které prodávají sledované produkty. Z nich poté v definovaných intervalech získává data. Z dat
je poté vytvořen výstup pro uživatele obsahující získané informace, které
se skládají především ze získaných cen. Výstup lze vizualizovat i na grafech ve webovém rozhraní nebo stáhnout ve formátu
\textit{csv} či \textit{xlsx}.
\par
Proces samotného hledání byl navržen jako soubor více kroků, skládající se z procesů interní částí a interakcí administrátora, který zajišťuje
řešení problémů, které systém nedokáže sám vyřešit.

\section{Návrh}
Řešení bylo rozděleno na část webového rozhraní a na část zpracovávající interní procesy, nazývanou v této práci 
jako interní část.
Vzhledem k požadavkům na škálovatelnost aplikace se druhá část skládá z více samostatných menších služeb - modulů komunikující
spolu pomocí front. Díky tomu, že každý modul zajišťuje určitou funkcionalitu a je možné vytvářet více jeho instancí, procesy lze 
zpracovávat paralelně a na více serverech, kde je jediné kritérium připojení na systém zajišťující komunikaci.
\par
Uživatelská a interní část pak spolu sdílejí data pomocí relační databáze\cite{DB}.

\section{Webové rozhraní}
Webové rozhraní lze rozdělit na dvě části. Uživatelskou, obsahující množinu podstránek určených pouze pro konečné uživatele
služby a část pro administrátory, sloužící k monitorování kampaní a řešení chyb. Webové rozhraní používá databázi, která pak 
obsahuje všechny uložené a získané data.
\par
Uživatelská část umožňuje vytvořit kampaň. Kampaň je proces trvající určitý časový úsek, který sleduje vložené produkty na konkurenčních
obchodech.
V rámci těchto běžících kampaních má poté uživatel možnost uživatel vidět vizualizaci získaných dat, případně je umožněn export dat do formátu
\textit{csv} či \textit{xlsx}. Získaná data obsahují, kde se sledované produkty nacházejí a za jakou cenu se prodávají.
\par
Druhá část je určena pouze pro administrátory. Slouží k monitorování kampaní uživatelů a řešení problémů, které systém není schopný 
automaticky vyřešit. Což je definování selektorů pro výběr dat z webových stránek, párování produktu ke stránce nebo potvrzení zda jsou získaná data validní.
\section{Interní část}
Interní část je rozdělena do samostatných modulů, které spolu komunikují pomocí front. Moduly je poté možné spustit jako služby ve více 
instancích, kromě modulu Manager. Vzhledem k možnostem front, je pak možné práci distribuovat na více serverů, aniž by byla ohrožena bezpečnost
databáze, jelikož k té je umožněný přístup pouze lokální. Moduly jsou detailněji popsány v následujících podsekcích.
\subsection{Manager}
Manager je hlavní modul, který má jako jediná interní část možnost připojení do databáze a jeho běžící instance může existovat pouze jednou.
Manager má za úkol plánování práce pro ostatní části systému a samotnou správu komunikace s ostatními moduly.
\subsection{Finder}
Finder je modul, který má za úkol získávat URL adresy internetových obchodů, které prodávají požadované produkty.
Na nalezeném obchodě poté vyhledávat adresy vedoucí na detail vyhledávaných produktů.
\par
Předpokládá se nemožnost přímo nalézt adresu vedoucí na detail produktu a proto je nutné ho pomocí interního vyhledávání obchodu takový
detail nalézt pokud existuje. Detail produktu pak obsahuje podrobné informace o prodávaném produktu.
\subsection{DataProvider}
DataProvider je modul, který zpracovává adresy vedoucí na detaily produktu. Zde existují čtyři hlavní větve možností zpracování požadavků.
Po stažení stránky se pokusí získat požadované
hodnoty. V případě neúspěchu odešle příslušnou chybu, v opačném případě zanalyzuje korektnost získaných cen vůči historickým datům pokud
existují. Výsledek je poté odeslán k zpracování Managerem.


\chapter{Vývoj a implementace týmového projektu}
V této kapitole se věnuji průběhu vývoje týmového projektu a vytvořenému řešení. Zmíním tedy zvolené postupy při vývoji a 
jaké technologie byly zvoleny.
\par
Poslední část rozebírá mou roli v tomto
projektu, jelikož mé téma bakalářské práce jsem měl předběžně vybrané, již na začátku předmětu BI-SP2.


\section{Pojmy}

\subsection{Verzovací systém Git}
Git \cite{GIT} je verzovací systém umožňující vytváření a sdílení jednotlivých verzí zvoleného projektu.
Umožňuje jednoduchý přehled nad rozpracovanými částmi každého vývojáře. Úložiště systému se nazývá repozitář, který obsahuje veškerý kód.
\par
repozitář existuje v lokálních verzi a zároveň serverové, tedy sdílené. Sdílený repozitář pak zajišťuje distribuci aktuální verze do lokálních 
repozitářů. Pro lepší správu pak existují nadstavby nad serverovou částí repozitáře, které umožňují jednoduchou
správu nad kódem a spouštění dalších služeb. Zde například spuštění sestavení aplikace nebo notifikace
při nové změně.
\par
Základní jednotkou tvoří verze, které jsou postupně vytvářeny vývojáři po vytvoření každé malé funkcionality.
Verze jsou poté uchovávány v jednotlivých větví programu. Vedlejší větve slouží pro samotný vývoj. 
Hlavní větve poté tento kód spojují a reprezentují aktuální vývojovou a produkční verzi. Git také zajišťuje základní nástroje pro slučování kódu v případě spojování nebo slučovaní vedlejších větví do větví hlavních.

\begin{figure}[h]\centering
 	\includegraphics[width=0.7\textwidth]{resources/branches}
	\caption[Větve v Git repozitáři]{Zobrazení větví v repozitáři, kde \textit{master} je produkční, \textit{develop} vývojová a \textit{topic}
	představuje větev vedlejší}\label{fig:vetev}
\end{figure}

\subsection{Jednotkové a integrační testy}
Jednotkovými testy se rozumí sada kladných a záporných testů ověřující funkcionalitu jediné třídy. Jednotkové testy
jsou nezávislé na ostatních třídách a testech. \cite{testing} 
Integrační testy pak pokrývají komunikaci více tříd nebo komunikaci s operačním systémem, hardwarem či rozhraním různých systémů. \cite{testing}
\par
Důvody pro psaní testů jsou například lehčí nalezení chyby nebo lepší udržovatelnost projektu. V případě neexistujících testů nelze ověřit původní
funkcionalitu při modifikaci aplikace, což může způsobit nutnost chyby nalézt a opravit.\cite{testing}

\subsection{Statická analýza kódu}
Statická analýza kódu je analýza softwarového produktu, která běží bez spuštění samotné aplikace. Kontroluje 
pouze samotný kód. Označuje kritické konstrukce vedoucí k chybám nebo nedodržení programátorských konvencí daného
jazyka.
\subsection{Průběžná integrace}
Průběžnou integrací se rozumí sada nástrojů sloužící k urychlení softwarového vývoje. Princip je průběžné sestavení
a spouštění testů aplikace na základě změny ve sdíleném repozitáři. Lze tak rychle odhalit případné chyby před zařazením 
příslušné verze do produkce.\cite{CI}

\subsection{Sdílení dat pomocí front}
Sdílení dat pomocí front funguje na principu odesílání zpráv, které reprezentují objekty. Zprávy jsou po zařazení do fronty odebírány
konzumenty, které je poté zpracovávají.
Příklad takového systému pak může být například RabbitMQ. \cite{rabbitMQ}

\section{Vývoj}
Vývoj byl rozdělen do 5 iterací, z nichž každá obsahovala 10 sprintů. V každé iteraci bylo poté definováno jaké musí obsahovat funkcionality,
které budou na její konci prezentovány vyučujícímu. Funkcionality byly rozděleny do jednotlivých úkoly a ty distribuovány do sprintů.
Úkoly byly poté přiřazovány členům týmu. Stav úkolů byl uchováván na systému Redmine\cite{Redmine}, který umožňuje sledovat stav úkolů.
Úkoly lze pak přiřadit k jednotlivým sprintům a iteracím, což umožňuje sledovat 


\par
Jako verzovací systém byl zvolen systém Git, se vzdáleným repozitářem uložený na službě Gitlab \cite{gitlab}. Gitlab poskytuje webové rozhraní pro snadnou správu a spouštění služeb na základě definovaných aktivit v repozitáři. Repozitář se skládal ze 4 částí (větví):
\begin{itemize}
\item Master - hlavní větev uchovávající verze určené k nasazení na produkční server
\item Develop - vývojová větev obsahující aktuální stav vývoje
\item Feature - vedlejší větev vytvořená pro konkrétní úkol přidávající novou funkcionalitu
\item Fix - vedlejší větev určená pro úkoly opravující chybu
\end{itemize}
Jelikož přístup k přidání verze do Master a Develop měl pouze vedoucí projektu, musel být pro každou Feature a Fix větev
vytvořen požadavek o zařazení. Po kontrole vedoucím byl požadavek zařazen nebo vrácen k opravě.
\par
Na konci každé iterace byla poslední verze označená pomocí \textit{tagu} a poté prezentována vedoucímu.
Označení bylo zvoleno na základě pořadí iterace. 1. iterace je označena verzí \uv{0.1}.
\par
Pro vývoj se využil princip průběžné integrace. Každá verze byla zkompilována, otestována a zanalyzována na vzdáleném serveru.
Tyto činnosti zajišťovaly systémy Jenkins\cite{jenkins} a Gitlab. Po změně v repozitáři, byl spuštěn úkol v Jenkins. Ten aplikaci sestavil, spustil testy a statickou analýzu kódu 
zajištěnou systémem SonarQube\cite{sonar}. Výsledky poté publikoval ve svém webovém rozhraní a zároveň v rozhraní Gitlab.  
\section{Implementace}


\subsection{Webové rozhraní}
Webové rozhraní je implementováno v jazyce PHP verze 7. Základem aplikace je aplikační rámec Nette\cite{nette}. Nette
obsahuje nástroje pro automatickou správu závislostí, komunikaci s databází, vytváření bezpečných formulářů, zabezpečení
aplikace, šablonovací systém a rozhraní pro tvorbu jednotkových testů. 
\par
Natte je navrženo s myšlenkou použití MVC architektury, která odděluje
prezenční a logickou vrstvu. Zkratka MVC značí Model-View-Controller. V případě webového projektu v Nette je pak view šablona definující vzhled webové stránky, controller třídy obsluhují šablony. Modelovou vrstvu poté zajišťují servisní třídy, vykonávající logické části aplikace jako 
například práci s repository třídami nebo zpracování formuláře. Repository se pak starají o přímou komunikace s databází.

\begin{figure}[h]\centering
 	\includegraphics[width=0.7\textwidth]{resources/mvc}
	\caption[MVC]{Vizualizace návrhu MVC (Model-View-Controller}\label{fig:mvc}
\end{figure}
\par
Snadnou správu závislostí nad externími knihovnami zajišťuje balíčkovací systém Composer\cite{composer}. 
Na základě souboru definující potřebné knihovny a jejich verze, jsou staženy z centrálního repozitáře. To zajišťuje jednotné verze knihoven
a eliminace nutnosti knihovny manuálně stahovat či přímo přidávat do repozitáře.
\subsection{Interní část}
Interní část je implementována v jazyce Java verze 8. Kompilaci, spouštění testů a správu závislostí zajišťuje Gradle\cite{gradle}.
Gradle je nástroj sloužící k automatickému sestavení aplikace. Dále umožňuje správu závislostí knihoven, kde je standardně nastavený jako zdroj
centrální maven repozitář. \cite{mavenRepo}. Maven repozitář uchovává většinu volně přístupných knihoven, v tomto případě všechny, které jsou v rámci toho projektu použity.
\par
V rámci sestavení lze pustit testy a další definované úkoly, které mohou být zajištěny přidanými doplňky. Projekt používá
doplněk Cobertura\cite{cobertura}, který na základě spuštěné testovací sady vytváří zprávu obsahující pokrytí větví programu.
Díky tomu lze jednoduše zjistit jaké větve aplikace nejsou otestované.
\par
Aplikace je rozdělena do nezávislých modulů běžící jako služby. Jednotlivé moduly spolu komunikují
pomocí posílání zpráv definovaných front. Komunikaci zajišťuje systém RabbitMQ Server implementovaný v jazyce Erlang. Zprávy jsou serializovatelné objekty, jejichž definice je sdílena napříč všemi moduly.
\par
Serializace představuje proces, kdy je objekt serializovaný do posloupnosti bitů, které jsou poslány jako zpráva. 
Vzhledem k sdílené podobě objektu na obou stranách, zprávu lze jednoznačně deserializovat zpět do původní Java objektu se kterým
je poté možné dále pracovat.\cite{serialization}
\par
Projekt využívá mnoho volně dostupných knihoven, nejpodstatnější jsou však následující:
\begin{itemize}
\item Google Guice - automatická správa závislostí \cite{guice}
\item Hibernate - objektově relační zobrazení databázových entit a práce s nimi \cite{hibernate}
\item Apache Commons - pomocné knihovny pro práci s řetězcemi a soubory \cite{commons}
\item RabbitMQ - zajišťuje komunikaci s frontami \cite{rabbitMQ}
\end{itemize}

\section{Má role}
V druhé části týmového projektu, samotné implementaci, jsem byl vedoucí týmu. Jelikož jsem již znal téma své bakalářské práce, 
věnoval jsem se projektu nad rámec předmětu.
\par
Na začátku projektu jsem vytvořil celý ekosystém, tvořený z přidružených služeb použitých při vývoji.
Zde se jedná především o projení následujících služeb s Gitlabem:

\begin{itemize}
\item Redmine - možnost prokliku na úkol na základě čísla ve zprávě verzované jednotky (commit message)
\item Jenkins - spouštění sestavení aplikace na základě nové verze, oddělené dle jednotlivých větví (hlavní, vývojová, vedlejší) a
				informace o výsledku
\item SonarQube - zobrazování interaktivního výsledku statické analýzy přímo v rozhraní Gitlab
\end{itemize}

Samotný SonarQube bylo nejprve potřeba nastavit, aby se spouštěl při sestavení aplikace a výsledek se poté zobrazil v rozhraní
Gitlabu. V rámci sestavení aplikace jsem ještě nastavil spouštění nástroje Cobertura.
Doplňky v Jenkins poté umožňovaly zobrazení přehledných výsledků, jak je kód pokryt testy. Přesné pokrytí testy mi poté umožňovali 
jednoduše kontrolovat, zda jsou správně napsané všechny testy.


\chapter{Zhodnocení týmového projektu}
Pro návaznost na kapitolu o provedených vylepšeních je nejprve nutné uvést v jakém kontextu jsou navrhovány. K tomu je třeba
popsat výsledný stav projektu a jeho funkcionalitu, čemuž se budu věnovat v této kapitole. Popíši jaký byl výsledný stav
řešení a nedostatky, které obsahovalo.

\section{Pojmy}

\subsection{JSON}
JSON označuje specifikaci formátu pro výměnu dat\cite{JSON}. Jedná se o formát, který je čitelný jak pro lidské oko tak pro stroj\cite{JSON},
Zpracování toho formátu je implementováno pro většinu programovacích jazyků\cite{JSON-impl}. Skládá se z párů označující
klíč a hodnotu. Kde hodnota může být řetězec, číslo nebo pole. Pole pak může uchovávat opět řetězec nebo číslo. \cite{JSON}

\begin{lstlisting}[language=JavaScript, caption={Ukázka formátu JSON}]
{
  "key": [
    1,
    2,
    3
  ],
  "boolean": true,
  "null": null,
  "number": 123,
  "object": {
    "a": "b",
    "c": "d",
    "e": "f"
  },
  "string": "Hello World"
}
\end{lstlisting}


\subsection{Web API}
Rozhraní, které na definovaný HTTP dotaz vrací data. Ty jsou standardně vracena ve formátech JSON nebo XML.

\section{Stav}
Ačkoliv stav projektu odpovídal nárokům na úspěšné odevzdání nebyla dosažena implementace všech procesů, aby byla umožněno reálné
použití systému.
\par
Odevzdávaný stav obsahoval funkční webové rozhraní, které se skládalo ze základní funkcionality pro uživatele a pro administrátory.
Část pro administrátory obsahovala správu uživatelů, možnost parsování stránek, evidenci známých obchodů a produktů či sledování
chyb vzniklých v interní části.
Uživatelská část umožňovala správu a vytvoření kampaně či kampaní. Implementace kampaní pak splňovala návrh z analytické částí,
která byla zmíněna výše.
Na žádost jiného týmu jsme také vytvořili Web API rozhraní, poskytující získané ceny pro daný produktu ve formátu JSON.
\par
Interní část byla schopná pracovat pouze na základě dříve uložených url adres vedoucí detaily produktů. 
Manager dokázal vybrat adresy detailů, které je potřeba aktualizovat.
\par
Na základě adres, vytvořil požadavky obsahující potřebná data. Požadavky odeslal pomocí front pro zpracování do DataProvideru. Ten na základě obdržených dat stránku vyparsoval a zanalyzoval výsledek vůči historickým datům a informacích o produktu, který se na adrese nachází.
\par
Analýza se především skládala z kontrol velkých výkyvů cen a rozdílných identifikátorů produktu.
V případě, že požadavek neobsahoval šablonu pro vyparsování nebo byl výsledek označen jako chybný a byla odeslána chyba
zpět do Manageru. Manager následně výsledek korektně uložil pro zobrazení ve webovém rozhraní, ať už se jednalo o chybu
nebo nalezení ceny.
\par
Byla také obsažena detekce opravených chyb, díky kterému Manager poznal, že může pokračovat v práci hledání cen na daném.

\section{Nedostatky}
Vytvořené řešení obsahovalo spoustu nedostatků, které je třeba v rámci této práce detekovat a ty nejdůležitější se pokusit opravit.
Z důvodu kontextu a odlišnosti od původního návrhu nejprve popíšu systém plánování práce, který je důvodem nežádoucího chování.

\subsection{Vytváření požadavků pro ProductProvider}
Některé nedostatky jsou úzce spjaty s tím, jak aplikace plánovala práci. Plánováním práce je myšlen proces
nalezení adres detailů produktů, kde je požadováno získat nové data. Z nich jsou poté vytvořeny požadavky pro ProductProvider k zpracování.
\par
Jak bylo řečeno, prvotním kritériem adresy detailů. Ty se mohou vyskytovat v různých stavech. Systém je vybral v 
následujícím pořadí, z kterého následně vybral první 10:

\begin{itemize}
\item Adresy, které mají produkty v zaplacené kampani
\item Adresy bez produktů
\item Adresy, pro které neexistuje šablona pro parsování
\item Adresy, které mají vyřešenou chybu
\end{itemize}

Z této množiny byly poté odebrány odeslané a ty které mají nevyřešenou chybu. Opakované spuštění v předefinovaném intervalu poté 
zajistilo, že požadavky byly vytvořeny pro všechny požadované adresy.
\par
Další nedostatek se skládal z ukládání stavu do databáze. Část nejdůležitějších atributů vytvářeného požadavku byla uložena do databáze 
s příznakem odesláno. Tento příznak bylo nutné uchovávat i u chyb, kde je potřeba označit, že byla zpracována. Zde se však 
ovšem nastavil příznak o zpracování, ale pokud se požadavek nepodařilo odeslat nebyl již změněn. To způsobilo, že chyba již 
nebyla nikdy zpracována.

\subsection{Neefektivní chování modulu Manager a ProductProvider}\label{ch:manager-pd}
První zásadní problém bylo neefektivní chování komunikace modulu Manager s ProductProviderem. V rámci testování jsem zjistil, že v 
případě chyby při parsování stránky není použit uložený HTML dokument.
To pramenilo z výše popsaného návrhu plánování, které nalezlo korektně adresy, ale vytváření samotného objektu představující požadavek,
bylo stejné pro všechny adresy. Vytváření tedy neobsahovalo použití již staženého dokumentu, na jehož základě byla vytvořena 
chyba parsování nebo analyzování. Každý požadavek tedy vyústil v opětovné stažení příslušné stránky.

\subsection{Chyby analyzování}
Poslední fáze procesu v modulu ProductProvider byla navržena jako analyzování získaných dat vůči již dříve uloženým. Implementace analyzátoru 
spouštěla jednotlivé validace, jejíž logika se nacházela v oddělených třídách. 
Analýza kontrolovala zda se shoduje získaný EAN, název a modelové číslo, vůči uloženým identifikátorům. Pokud na jedné ze stran hodnota neexistovala
byly data označená, že jsou pravděpodobně chybná. Dále probíhala kontrola získané ceny s a bez DPH oproti cenám získané na konkrétní stránce dříve.
Kontrola zde porovnala průměr historických hodnot se získanými cenami. V případě, že rozdíl byl větší jak 25\%, byl výsledek označen jako
možná chyba.
\par
V případě, že validační třída objevila nežádoucí data,
vyhodila výjimku ve které byly uložené informace o chybě. Tento způsob řízení programu však způsoboval, že celá validace skončila při první chybě.
Zároveň obsah výjimky pouze určoval typ validace bez přídavných informací.
\par
Informace byly následné odeslány a manager na jejich základě vytvořil chybu pro administrátora k vyřešení. Administrátor mohl 
poté označit, zda je to opravdu chyba nebo se má do budoucna ignorovat.
\par
V prvním případě se chyba přestala používat, v druhém byl vytvořen příznak označující, že se na daném obchodě vyskytují jiné identifikátory
nebo skokové změny ceny a validační chyba byla zahozena. Problém nastával pokud se na adrese objevilo více chyb. To znamenalo, že každý další požadavek vytvořil další
chybu analyzátoru a administrátor tak musel všechny vyřešit. Při každém požadavku pak bylo nutné obsah adresy znova stáhnout.

\subsection{Vytváření chyb šablon}
Jako další problém se ukázalo plánování práce založené na kritériu, kdy jsou k vytvoření požadavku vybrány všechny adresy, které neobsahují šablonu.
Myšlenka byla taková, že pro vytvoření samotné šablony, je nutné nejdříve stránku stáhnout, nechat vytvořit chybu parsování
a následně chybu vyřešit.
\par
Systém však odeslal požadavek pro všechny uložené adresy na obchod. To vyústilo ve vytvoření mnoho chyb, 
které musel administrátor všechny postupně vyřešit.
\par
\subsection{Modul Finder}
Modul Finder nebyl zapojený do systému. Existovala pouze hlavní implementace interních procesů, jejíchž funkčnost byla
pouze ověřena jednotkovými testy. Neexistující rozhraní pro práci s frontami a příslušných tříd Managera zajišťující vytváření příslušných požadavků
neumožňovaly ověření celkové funkcionality této části. Z tohoto důvodu nebyl systém jako celek použitelný pro jakékoliv reálné použití, jelikož
jediná možnost jak využít funkcionalitu interní částí, bylo vytvořit SQL insert skripty, obsahující adresy detailů produktů
a ty spustit nad databází, kterou systém používal.
\par
Další důsledek byla neexistence procesu párování produktů. Finder byl navržený tak, že po nalezení internetového obchodu
pomocí interního vyhledávání nalezne detaily produktů, u kterých je velká pravděpodobnost, že patří hledanému produktu.
Zda se však jedná o spravný detail produktu je však třeba ověřit, jelikož výstupem může být více adres. Po získání hodnot ze stránky je tak třeba nežádoucí adresy vyloučit a ostatní spárovat s produktem.
\subsection{Plánování práce}
Projekt neobsahoval plánování práce vůči požadovanému intervalu, kdy mají být nová data
staženy. Jak bylo řečeno výše, aktuální stav pouze hledal adresy produktů, které se nachází v zaplacené kampani nebo měli vyřešenou chybu.
\subsection{Škálovatelnost}
Původní návrh počítal se škálovatelností aplikace na více serverech, kde je možné vytvořit neomezený počet instancí DataProvider a Finder. Reálný stav
na konci projektu však tuto možnost nevyužíval, ač to bylo možné. Interní část tak běžela jako jedna služba. Po spuštění
byly inicializovány všechny moduly běžící v samostatných vláknech.
\subsection{Obecný návrh a testy}
Implementace samotná, byla velmi nepřehledná. Vykytovaly se prvky značící špatný návrh aplikace.
Zde bych rád zmínil například dlouhé a nepřehledné metody v
DataProviderServiceImpl a AbstractFinderUrlListWorkerImpl, kde ačkoliv jejich velikost 
nepřesahovala 60 řádků bylo velmi obtížné zjistit, co mají vykonávat. Problém byly také velké třídy
jako například DataProviderServiceImpl zajišťující celý proces v modulu DataProvider.
\par
Je nutné podotknou, že spoustu špatných konstrukcí byly eliminovány již v průběhu vývoje týmového projektu.
První důvod byla automatická analýza kódu detekující konstrukce, které jsou zdrojem častých chyb. Automatická analýza
však nebyla schopná najít všechny problémy. Druhý důvod byla moje kontrola při schvalování vytvořeného kódu pro 
zadaný úkol. Z důvodu časové tísně, ale nebyl vždy čas na to vrátit kód k přepsaní a opravení všech nedostatků. To způsobilo, že
se vědomě dostaly do hlavních větví konstrukce, které nebyly považovány za ideální s myšlenkou, že budou přepracovány později, což se ne vždy povedlo.
\par
Další problém návrhu byly procesy v DataProvider modulu řízené pomocí výjimek obsahující 
přídavné informace i v případech, kdy byl takový výsledek očekávaný nebo dokonce chtěný. 
Toto použití je však v rozporu ideou použití výjimek, které mají signalizovat neočekávaný stav, kdy není možné dále pokračovat.\cite{exception}
Pro uchování přídavných informací bylo nutné vytvářet výjimky vlastní, které obsahují přesnější údaje o chybě. Ani tyto údaje však nebyly 
dostatečné a tak nebylo možné přesně rozpoznat ve webovém rozhraní přesný důvod chyby.
\par
V kritických částech chyběly některé důležité testy, jelikož třídy snažící se dělat více věcí najednou by bylo velmi
složité otestovat. Chybějící testy se vykytovaly například u následujících částí: databázová vrstva, fasády, vytváření požadavků pro DataProvider,
hlavní servisní třída DataProvideru nebo validace dat analyzátorem. Z tohoto důvodu jakákoliv oprava nebo implementace nových požadavků 
mohla narušit stávající funkcionalitu bez možnosti rychlého ověření. Tím by mohla být jakákoliv změna velmi časově náročná a s velmi nejistým konečným výsledkem.

Systém proto v tomto stavu nebyl vhodný pro následný rozvoj.

\begin{figure}[h]\centering
 	\includegraphics[width=1.0\textwidth]{resources/cobertura-report-old-1}
 	\includegraphics[width=0.7\textwidth]{resources/cobertura-report-old-2}
	\caption[Pokrytí testy vytvořeného řešení]{Pokrytí testy vytvořeného řešení. Získáno pomocí nástroje Cobertura. Vizualizace
	výsledků byla vytvořena při sestavení na Jenkins s příslušným doplňkem.}\label{fig:dp-dia}
\end{figure}


\chapter{Návrhy na vylepšení}
V této kapitole popíšu návrhy na možná vylepšení. Samotné implementaci se poté věnuji v následující kapitole. 
Nedostatky, které byly zjištěny až v průběhu implementace vylepšení a nebyly zároveň i opraveny budou zmíněny v kapitole týkající se zhodnocení
provedených vylepšení.

\section{Pojmy}

\subsection{Mock}
V objektově orientovaném programování se Mock objekt používá pro simulování chování konkrétní třídy.\cite{mock}
Při testování je tedy možné docílit takových testů, které nejsou závislé na ostatních třídách, kromě té přímo testované.
\par
Testovaná třída obvykle vyžaduje závislost na jiných třídách či rozhraní. Pomocí Mocku je možné chování těchto tříd simulovat.
Mimo nadefinování požadovaného chování, lze také na Mock objektu sledovat jaká na něm byly provedené volání, včetně toho
s jakými parametry. Díky tomu je možné testovat i vnitřní chování testované třídy a ne pouze návratovou hodnotu na základě 
obdrženého vstupu.

\subsection{Refaktorování kódu}
Refaktorování v softwarovém vývoji chápeme jako proces restrukturalizace existující kódu, aniž by byla 
pozměněna funkcionalita. Provádí se za účelem dosáhnout průhlednějšího a čitelnějšího kódu, který
se lépe udržuje a rozšiřuje. \cite{refaktoring} Hlavní spouštěcí příčina refaktorování kódu je však existence 
konstrukcí značící špatný návrh aplikace. 

V kontextu této práce jsou důležité především následující konstrukce značící možné problémy: \cite{refaktoring} 
\begin{itemize}
\item Dlouhá metoda
\item Velká třída
\item Dlouhý seznam parametrů
\item Složité struktury podmínek
\end{itemize}

\section{Refaktorování stávajícího řešení}
Vzhledem k výše popsaným problémům týkající se samotné implementace v interní části, je potřeba tyto nedostatky napravit.
Na existujícím kódu však není možné stavět opravy nebo přidání nových funkcionalit. Příčina jsou konstrukce jako
dlouhé metody, velké třídy nebo dlouhé seznamky parametrů.
Z těchto důvodů je třeba vhodně interní část refaktorovat, tak aby bylo možné kód lépe udržovat a rozvíjet. Provedené změny následně 
otestovat pomocí jednotkových testů.
\par
V rámci refaktorování je třeba se pokusit zachovat co nejvíce původního kódu, obzvlášť takový, kde je ověřena funkcionalita.
Dále pro větší přehlednost přesunout všechny servisní třídy do samostatného balíku a sjednotit je. Jednotlivé funkcionality
budou poté v samostatných balíčcích.
\par
Při úpravách musí být kladen důraz na nastavení komunikace jednotlivých tříd.

\subsection{Řízení aplikace}
Chování modulu ProductProvider je řízeno pomocí chytání výjimek obsahující informace o chybě. 
Výjimky by bylo vhodné odstranit a návratové hodnoty změnit na objekt obalující celkový výsledek. Tento návrh poté ulehčí běh procesů, kde není žádoucí
skončit při první chybě. Kód bude možné lépe rozdělit a metody následně zkrátit, což výrazně zlepší přehlednost kódu.

\section{Plánování práce}
Samotná logika plánování práce, tedy nalezení adres detailů, které chceme použít v vytváření požadavků, se ukázala být nedostatečná. Chybí 
požadovaná funkcionalita, použití intervalu určující, kdy je požadován nový výstup. Není také implementováno odstranění adres, kde
z nějakého důvodu není vyžadováno vytvářet a odesílat požadavek.
\par
Nový návrh tedy hledá adresy podle těchto kritérií:

\begin{itemize}
\item Adresy, které mají produkty v aktivní kampani a požadovaný interval hledání odpovídá aktuálnímu dni
\item Adresy bez produktů
\item Adresy, pro které neexistuje šablona pro parsování
\item Adresy, které mají vyřešenou chybu
\end{itemize}

Po nalezení těchto disjunktních množin a odstranění duplicit jsou vyřazeny adresy, které z nějakého důvodu nevyhovují svým stavem.
Nežádoucí stavy jsou momentálně tyto:

\begin{itemize}
\item Pro obchod existuje nevyřešená parsovací chyba
\item Existuje nevyřešená chyba analyzátoru
\item Požadavek pro adresu byl již odeslán
\end{itemize}

Stavy je potřeba implementovat takovým způsobem, kdy bude velmi jednoduché 
kdykoliv kontrolu přidat nebo odebrat.

\section{Oprava komunikace Manager - ProductProvider}
Vzhledem k problémům popsaných v kapitole týkajících se zhodnocení \ref{ch:manager-pd}, je třeba komunikaci těchto dvou modulů optimalizovat. Neefektivní chování je
velký problém při zpracování velkého počtu dat, především při nutnosti opakovaného stahování webových stránek. 
\par
Při analýze kódu se ukázalo, že v aktuálním návrhu aplikace není možné tuto funkcionalitu jednoduše implementovat, aniž by se nejednalo o rychlou opravu neefektivním řešením. Oprava by znamenala, že pro každou vytvářenou adresu se systém musí pokusit najít
existující chybu a poté využít staženou stránku. Hledání by tak probíhalo ve většině případů zbytečně, jelikož chyba by neexistovala.
\par
Korektní oprava je úzce spjata s předchozími kapitolami, především s refaktorováním a úpravou plánování práce. Pokud úprava plánování zachová
informaci o přičině udávající, proč je adresa pro vytvoření požadavku zařazena, stačí poté pouze nalézt potřebné atributy a ty uložit.
\par
Informace by však měla být zachována i při odesílání, kdy je třeba nastavit příznaky o odeslání a zpracování šablony. V případě
kdy se požadavek nepodaří odeslat musí příznak odpovídat tomuto stavu. Z hlediska DataProvider stačí pouze zkontrolovat, zda existuje
stažená stránka v požadavku a v kladném případě ji nestahovat znova.

\section{Spojení chyb analyzátoru a vylepšení rozhraní} \label{analyser-join}
Analyzátor provádí kontrolu získaných dat. V případě podezření o nevalidních datech je vytvořena chyba, určena k vyřešení
administrátorem. Validace kontrolují ekvivalenci identifikátorů vůči již uloženým a velké výkyvy cen na daném obchodu.
\par
Administrátor má poté možnost chybu vyřešit a uložit příznak, aby se chyba do budoucna ignorovala. Toto rozhodnutí je však
založené pouze na informaci obsahující jaká validace se nepovedla. Nemá tak možnost porovnat jaká data byla využita při validaci.
Webové rozhraní aktuálně nemá možnost zobrazit dodatečná data, protože nejsou k dispozici. Interní část by měla takové informace
získávat a uložit do databáze. Webové rozhraní poté může tyto informace použít.
\par
V případě adresy, která obsahuje více chyb je nutné řešit každou samostatně, kdy je po každém vyřešení počkat na zpracování interní částí.
Zde je nutné požadováno chyby spojit do jedné, tak aby administrátor mohl vyřešit všechny možné chyby analyzátoru najednou.
\section{Monitorování}
Na virtuálním serveru probíhá sestavení aplikace, včetně všech dodatečných procesů. Dále zde běží vývojová a produkční verze interní i webové části.
Momentální stav poskytuje pouze omezenou možnost, jak sledovat využití prostředků virtuálního serveru.
\par
Pro lepší přehled běžících prostředků by bylo tedy vhodné zvolit monitorovací službu, která umožňuje unifikovat sledování
probíhajících procesů na serveru, včetně vytížení a zobrazovalo stav na jedné stránce.

\section{Získání adres obchodů a příslušných detailů produktů}
Interní část vyžaduje ke své funkcionalitě, již uložené adresy detailů produktů, na kterých jsou poté získávány data pro produkty.
Původní návrh však počítal s modulem Finder, který se však nepodařilo zapojit v rámci týmového projektu. Ten 
měl za úkol hledat internetové obchody na cenových srovnávačích a na nich pomocí vyhledávaní nelézt konkrétní adresy.
\par
Funkce Finderu je navržena jako duální, zajišťuje tedy jak hledání samotných obchodů, tak i detailů adres. Komunikační třída, představující příslušný požadavek, proto musí obsahovat příznak o jaký typ požadavků se jedná. Jelikož předávané informace
jsou ale odlišné, vytvořený požadavek obsahuje velké množství prázdných hodnot, což přispívá k celkové nepřehlednosti.
\par
Z tohoto důvodu navrhuji rozdělení Finderu na dva samostatné moduly. První bude zastávat funkci hledání obchodů a druhý
vyhledávat na obchodu a získávat požadované adresy detailů.


\section{Párování produktu}
Po nalezení adresy detailu produktu, stažení v DataProvider modulu a následném vyparsování hodnot je třeba adresu spárovat s 
existující produktem. Příčina nutnosti párování je, že po nalezení adresy detailu není jisté, zda opravdu patří produktu, pro který 
byla nalezena. 
\par
Párování musí být provedeno s velkou jistotou. Proto navrhuji vytvořit proces, který se nejprve pokusí produkt spárovat na základě
přesné shody některého z identifikátoru, což představuje název, modelové číslo nebo EAN produktu. 
\par
Proces není možné zcela zautomatizovat, jelikož velká část internetových obchodů neposkytuje na svých stránkách validní informace.\cite{hunka}
Buď obchod používá název, který není oficiální od distributora nebo jsou odlišné od uložených identifikátorů. Odlišnosti identifikátorů může způsobit například jiná barva nebo přidaná velikost za nebo před modelové
číslo. Jako řešení se jeví hledat podřetězec modelového čísla a EAN kódu, což řeší i problém pokud je ze stránky vyparsován text okolo
identifikátoru. Obchod také může poskytovat pouze název, což lze demonstrovat na obchodu \textit{glamot.cz}, například
pro produkt 
\href{https://www.glamot.cz/p/19128/difuzer-k-vysouseci-babyliss-pro-difuser-murano}{BaByliss PRO Difuser Murano \textit{[cit. 24.4.2017]}}.
\par
V případě neúspěchu párování, musí existovat možnost produkt spárovat manuálně, tedy akcí administrátora. 
Výše uvedený proces pak spoléhá na to, že vložená data při vytváření kampaně jsou validní. V případě nevalidních dat jako třeba
příliš obecných a krátkých názvů by párování proběhlo chybně.


\section{Neimplementované návrhy}
\subsection{Pokročilé párování produktu}
Párování produktu lze vylepšit o uchovávaní více hodnot pro identifikátory produktů, které systém může použít při dalším 
párování na jiných obchodech. Ukládání nových identifikátorů by mělo probíhat pouze se souhlasem administrátora, aby byla zajištěna validita dat.

\subsection{Uchování hodnot z nespárovaných adres}
Vyhledáváním na obchodu je zpravidla výsledek, který obsahuje více adres detailů produktu. Většina jich je v době hledání nepotřebná, nicméně v budoucnu mohou být využity. Pro dlouhodobě 
efektivnější chod systému se proto jeví uchovávat získaná data. Zde se jeví možnost získaná data z detailů uchovávat mimo interně uložené produkty
a v případě přidání nových produktů do systému v rámci vytvořené kampaně se pokusit najít shodu v těchto datech. To umožní odlehčení zátěže
na stahování stránek a celkové zrychlí chod systému.
\par
Získaná data a k nim adresy však mohou být neaktuální, kdy obchod už daný produkt neprodává a nebo adresa již nefunguje. Zde je proto nutné
nastavit mechanismus maximálního stáří dat při použití nebo ověření zda jsou platná.


\chapter{Realizace vylepšení}
Kapitola realizace vylepšení se věnuje implementovaným vylepšení. Popisuje jak byly navržené změny provedeny.
V průběhu realizace byly objeveny nové nedostatky, z nichž některé byly také zpracovány, i když se s nimi původně nepočítalo.
Změny jsou v repozitáři webového rozhraní a interní části označeny. Původní verze týmového projektu byla označena jako
tag \textit{v0.53}, realizované vylepšení jsou poté označeny jako \textit{v0.6}

\section{Refaktorování stávajícího řešení}
První krok realizace bylo refaktorování stávajícího řešení. Zde bylo provedeno především přesunutí tříd do jednotného balíčku, 
rozdělení tříd na více malých, zkrácení dlouhých metod, zmenšení počtu parametrů metod a nahrazení výjimek za návratové typy.

\subsection{Servisní třídy}
Pro větší přehlednost byly všechny servisní třídy do nadřazeném balíčku \uv{service}. 
Servisní třídou jsou takové, které nespadají do ani jedné z těchto skupin:

\begin{itemize}
\item Obsluha frekvenčního probouzení aplikace v daném intervalu
\item Rozhraní komunikující s frontami
\item Třídy přistupující k databázi (DAO)
\item Fasády, které obalují komunikaci servisních a DAO tříd
\item Konfigurační soubory automatické správy závislostí
\item Komunikační třídy
\item Pomocné třídy
\end{itemize}

Třídy jsem poté pojmenoval pomocí nové konvence, kdy důležité servisní třídy obsahují prefix jakého modulu se týkají
a postfix \textit{service}. Důvod byl větší přehlednost v projektu, kdy docházelo k podobným názvům napříč moduly.
\par
Změnu lze demonstrovat například na třídě zajišťující získávání dat ze stažené stránky. Třída \textit{cvut.fit.dataprovider.parser.ParserImpl} byla pak změněna na \textit{cvut.fit.dataprovider.service.parser.DPParserServiceImpl}. Následující řetězce uvádějí název včetně 
nadřazených balíčků, kdy název samotné třídy je v prvním případě \textit{ParserImpl}.

\subsection{Řízení aplikace}
Řízení aplikace, především v DataProvideru bylo řízeno pomocí výjimek, které způsobovaly problémy pro budoucí úpravy 
popsané v návrhu na vylepšení.
V návaznosti na tento návrh tak byly odstraněny a nahrazeny úpravou návratového typu, který obsahuje příznak výsledku 
a příslušné informace.
\par
Návratový typ lze demonstrovat na následují zkrácené třídě \textit{DPParserRespose}, která je vrácena v DataProvider modulu
po provedení parsování.

\begin{lstlisting}[language=Java]
/**
 * Entity to keep parsed response. Almost every 
 * attribute can be null, 
 * so getters return {@link Optional} of nullable type.
 *
 * @author Jakub Tucek
 * @created 24.1.2017
 */
public class DPParserResponse {

    /**
     * Flag for keeping result of parsing
     */
    boolean finishedProperly;

    /**
     * Parsed name of the product
     */
    private String name;

    public boolean isFinishedProperly() {
        return finishedProperly;
    }

    public void setFinishedProperly(
    	boolean finishedProperly) {
    	
        this.finishedProperly = finishedProperly;
    }

    public Optional<String> getName() {
        return Optional.ofNullable(name);
    }

    public void setName(String name) {
        this.name = name;
    }
}
\end{lstlisting}

Tato struktura je použita jako návratový typ rozhraní a implementace části pro parsování hodnot 
ze stažené stránky v modulu DataProvider. Ukazuje použití příznaku označující, zda parsování proběhlo korektně. Další důležitý prvek
je zapouzdření proměnným uchovávající data a přístup k ním je možný pouze pomocí \textit{get} a \textit{set} metod.
\par
Třídy přistupující k datům, jsou tak odstíněny od implementačnímu detailu třídy a odstínění irelevantních detailů implementace \cite{encapsulation}.
Metody \textit{get} jsou pak oproti standardnímu návrhu pozměněny tak, že nevrací přímo proměnnou, ale \textit{Optional} této proměnné.
Optional je kontejner, který může nebo nemusí obsahovat prázdnou hodnotu \cite{optional}. Před přístupem k hodnotě je proto vyžadováno se objektu zeptat, zda obsahuje hodnotu. Mechanismus očividné demonstrace, že hodnota může být prázdná, pak zamezuje nežádoucím výjimkám, především \textit{NullPointerException} \cite{nullPointerException}.
\par
Po nahrazení návratovými typy, jsou pak výjimky použity pouze v případech, kdy nastal neočekávaný stav a je nutné přerušit následující akce.

\subsection{Odstranění výjimky a spouštění validací}
Odstranění výjimek z interní části lze demonstrovat na změnách tříd zajišťující analyzování získaných výsledků v modulu DataProvider. Hlavní změny v této části jsou tři.
\par
První je přesunutí hlavního rozhraní \textit{Analyser} a jeho implementace
\textit{AnalyserImpl} z balíčku \textit{cvut.fit.dataprovider.analyser} 
do  \\
\textit{cvut.fit.dataprovider.service.analyser}. 
\par
Druhá změna představuje změnu rozhraní, kdy bylo potřeba
zmenšit počet parametrů a odstranit výjimku, která byla vyhozena v případě nalezení chyby. 
\par
Třetí změna je poté samotné spouštění 
validací. V původním řešení byla třída závislá na všech příslušných validací, které spustila, ale skončila při první chybě, což je jedna 
z příčin chování, které jsem popsal v kapitole poukazující na možnosti spojení chyb analyzátoru \autoref{analyser-join}.
\par
Vytvořil jsem nový návrh, který je pak použit i na ostatních místech interní části v závislosti na
prováděných vylepšení. Analyzující servisní třídě jsem odebral jednotlivé závislosti na konkrétních validacích a nahradil je množinou 
obsahující validační rozhraní. Validační rozhraní je pak nastaveno v konfiguračním souboru automatické správy závislostí, kde je možné
definovat jaké validace se mají použít.
\par
Validačnímu rozhraní byl také změněn návratový typ na \textit{Optional} případné zprávy o chybě. Pokud chyba nenastala je vrácena
prázdná hodnota. Implementace těchto rozhraní byly rozděleny podle toho, jakou hodnotu kontrolují.
Při úpravě validací jsem zároveň zjistil, že základní validace lze rozdělit na dvě skupiny, validace řetězce a čísla.
\par
V případě těchto skupin se vytvořený kód lišil pouze v jom, aká hodnota se má získat ze získaných dat a z dat již uložených.
Poslední rozdíl byl poté pouze v chybové hlášce. Z toho důvodu jsem společnou logiku obou skupin implementoval
pomocí abstraktní a generické třídy \textit{AbstractAnalysis}. Vlastnosti kontrol jednotlivých skupin pak zajišťující třídy \textit{AbstractStringAnalysis} 
nebo \textit{AbstractPriceAnalysis}. Výsledná validace kontrolující, zda získaná hodnota odpovídá již uložené hodnotě pak
vypadá následovně:

\begin{lstlisting}[language=Java, caption={Validace kontrolující hodnotu získaného jména produktu}]
/**
 * NameAnalysis is extension of {@link AbstractStringAnalysis} for analysing Name.
 *
 * @author Jakub Tucek
 * @created 27.1.2017
 */
public class NameAnalysis extends AbstractStringAnalysis {

    /**
     * {@inheritDoc}
     */
    @Override
    boolean skipAnalysis(DataProviderRequest request) {
        Optional<ComAnalyserFlags> analyserFlags = request.getAnalyserFlags();
        return analyserFlags.map(ComAnalyserFlags::isIgnoreDifferentName)
                .orElse(false);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    Optional<String> getOptionalProperty(DPParserResponse parserResponse) {
        return parserResponse.getName();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    List<String> getComProductValues(ComProduct comProduct) {
        return comProduct.getNames();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    AnalysisErrorMessage generateAnalysisErrorMessage(String comProductValue, String parsedValue) {
        return new AnalysisErrorMessage()
                .withErrorMessage(
                        String.format("Parsed name value[%s] doesn't match known name value[%s]",
                                parsedValue, comProductValue)
                )
                .withErrorType(AnalysisErrorType.DIFFERENT_NAME);
    }
}
\end{lstlisting}
Jednotlivé validace implementují pouze metody, která vrací jaká hodnota byla získaná a historické hodnoty. Dále kontroluje zda
se má daná validace ignorovat, či nikoliv. Poslední implementovaná metoda vytváří informace o případné chybě, které byly
v původním řešení nedostatečné. Tomuto problému je však věnována samostatná kapitola.
\par
Konečné spuštění validací bylo ve výsledku zkráceno na metodu obsahující jeden řádek kódu, ačkoliv tento řádek
obsahuje více zřetězených volání.
\par
\begin{lstlisting}[language=Java, caption={Upravená implementace hlavní metody ve třídě zajišťující spouštění validací analyzátoru}]
    /**
     * Runs analysis for given {@link DataProviderRequest} and {@link DPParserResponse}.
     * Error are returned as list of {@link AnalysisErrorMessage}.
     * Injected set of {@link Analysis} is executed one by one, result unwrapped and kept if present.
     * Set of analysis result error messages is returned.
     *
     * @param request        dp request
     * @param parserResponse parsed data
     * @return list of errors or empty (if result was valid)
     */
    @Override
    public List<AnalysisErrorMessage> runAnalysis(DataProviderRequest request, DPParserResponse parserResponse) {
        return analysisSet.stream()
                .map(x -> x.analyse(request, parserResponse))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());

    }
\end{lstlisting}
\par
\begin{lstlisting}[language=Java, caption={Původní implementace hlavní metody ve třídě zajišťující spouštění validací analyzátoru}]
    /**
     * Analyses the new product info in comparison with the history
     *
     * @param newInfo        the new product info to be analysed
     * @param newData
     * @param oldInfo        the old product info
     * @param productHistory the history of the product info   @throws AnalyserException when analysing fails, contains error type
     * @param analyserFlags
     */
    @Override
    public void analyse(ComProduct newInfo,
                        ComProductHistory newData,
                        ComProduct oldInfo,
                        List<ComProductHistory> productHistory,
                        ComAnalyserFlags analyserFlags) throws AnalyserException {
        ValidatorData data = new ValidatorData(newInfo, newData, oldInfo, productHistory, analyserFlags);
        try {
            eanValidator.validate(data);
            partNumberValidator.validate(data);
            priceValidator.validate(data);
            namesValidator.validate(data);
        } catch (AnalyserException e) {
            logger.info("Analysis failed for product id: {}", newInfo.getProductId(), e);
            throw e;
        }
        if (!data.getWarnings().isEmpty()) {
            //No handling neeeded at the moment
        }
    }
\end{lstlisting}
Jak bylo zmíněno, podobná architektura spouštění validací se vyskytuje na více místech interní části, například validace po provedení
parsování nebo kontrol zda má být požadavek či adresa použita při plánování práce.


\section{Plánování práce}
Plánování práce bylo rozděleno do tří částí, Nalezení adres, vytvoření požadavků a samotné odeslání.
Tato kapitola se pak týká pouze samotného nalezení adres, které je požadováno použít v dalším zpracování.
\par
V rámci hledání samotných adres byly implementovány servisní třídy, které samotné adresy hledají podle kritérií popsaných v 
návrhu vylepšeních. Následně jsou vráceny rozdělené dle způsobu nalezení. Nalezení adres nově počítá i s frekvencí, 
která je nastavena u aktivní kampaně.
\par
Nalezené adresy všechny typů jsou poté vyfiltrovány o nežádoucí stavy. K tomuto účelu jsem navrhl rozhraní kontrol, rozhodující 
o tom, zda je požadované adresu použít. Návrh se pak podobá kontrolám analyzátoru.

\section{Oprava komunikace Manager - ProductProvider}
Důležitý prvek samotné opravy komunikace modulů Manager a ProductProvider je samotné vytváření požadavků z nalezených adres.
Vzhledem k změně rozhraní, které zachovává způsob nalezení, stačilo vytvořit ostatní části Managera, tak aby odpovídalo novému rozhraní.
\par
Celý proces v Managerovi je rozdělen do tří částí a to nalezení adres, vytvoření požadavků a samotné odeslání. Hlavní metoda servisní třídy \textit{DPRequestSenderServiceImpl} vypadá následovně:
\begin{lstlisting}[language=Java]
    /**
     * Creates requests and sends them.
     *
     * @throws MQConnectionException when sending fails
     */
    @Override
    public void createRequests() throws MQConnectionException {
        ProductUrlSets requiredProductUrls = prioritizeService.findRequiredProductUrls();

        DPRequestProductUrlWrapper dpRequestWrapper = requestBuilderService.create(
                requiredProductUrls);


        senderService.sendDPRequests(dpRequestWrapper);
    }
\end{lstlisting}
Vzhledem v zásadní změně architektury neuvádím původní kód, jelikož celkový způsob vytváření požadavků je značně odlišný a není proto možné jednoduché porovnání. Vytváření bylo v předchozím řešení ve stejné třídě, která zajišťovala i odesílání, což způsobovalo problém při ukládání příznaků do databáze.
\par
Nový návrh vytváření požadavků tento proces deleguje do nové 
třídy \textit{DPRequestBuilderServiceImpl}, která zajišťuje uložení všech potřebných atributů do nového požadavku. Návratový typ této třídy pak slučuje množiny požadavků obsahující adresy bez produktů a 
ty v aktivní kampani, jelikož po vytvoření požadavků, již není potřeba odlišné chování k těmto požadavkům. Ostatní množiny jsou pak 
zachovány. Vzhledem k potřebě pracovat s adresou detailu i při odesílání požadavků, obsahuje \textit{DPRequestProductUrlWrapper}
množiny obsahující dvojice požadavek a adresa detailu. Důvod je odpadnutí nutnosti hledání chyby podle identifikátoru, což je potřeba
při ukládání příznaku chyby o zpracování.

\subsection{Odesílání požadavků}
Odesílání požadavků jsem upravil, aby odpovídalo novému návrhu. Před odesláním je každý požadavek uložen do databáze a nastaven
příznak o zpracování. V případě neočekávané chyby při odesílání, jsou tyto příznaky korektně změněny.
\par
Samotné odeslání má u všech požadavků stejný postup. Nejprve jsem proto extrahoval části obsahující ukládání a změnu stavu požadavků či chyb do samostatné třídy
\textit{DPRequestPersistServiceImpl}. Poté jsem využil nativního rozhraní Java 8 \textit{Consumer<T>}, které reprezentuje
operaci, která přijímá jeden vstup a nevrací žádný výsledek. Rozhraní jsem použil k reprezentaci operace uložení a
změny stavu v případě chyby.
\par
\begin{lstlisting}[language=Java, caption={Společná metoda zajišťující odeslání DataProvider požadavků}]
    /**
     * Sends request via {@link RequestHandler}.
     * Request is first persisted via {@link PersistanceDPRequestFacade} and it's id is set to the request in wrapper
     * object. If failure while sending object through MQ occurs, then {@link Consumer} failureHandler is called,
     * exception logged and rethrown.
     * Package private because of static code analysis.
     *
     * @param requestProductUrl wrapped object containing {@link cvut.fit.persistence.entity.ProductUrl}, {@link DataProviderRequest}
     * @param persistConsumer   persisting consumer that is called before sending
     * @param revertConsumer    revert consumer that is called in case of sending failure
     */
    void send(DPRequestProductUrl requestProductUrl,
              Consumer<DPRequestProductUrl> persistConsumer,
              Consumer<DPRequestProductUrl> revertConsumer) {
        try {
            persistConsumer.accept(requestProductUrl);
            providerRequestHandler.send(
                    requestProductUrl.getDataProviderRequest());
        } catch (MQConnectionException e) {
            revertConsumer.accept(requestProductUrl);
            logger.error("Sending dataProviderRequest error.", e);
            throw new IllegalStateException(e);
        }
    }
\end{lstlisting}

Zde je nutné podotknou důvod, proč není po odchytnutí a zpracování výjimky vrácena opět \textit{MQConnectionException}. 
Zvolený způsob iterace nad objekty a samotného volání odesílací metody, totiž neumožňuje volat v těle metodu
vyhazující výjimku rozšiřující třídu \textit{Exception}.
Tento nedostatek architektury lze pak vyřešit pomocí \textit{IllegalStateException}, která potomkem třídy \textit{Exception} není a lze
v rozhraní využít.
\par

\begin{lstlisting}[language=Java, caption={Příklad zavolání metody odesílající požadavky}]
        dpRequestWrapper.getAnalyserErrors().forEach(x -> send(
                x,
                dpRequestPersistService::persistRequestAnalyserError,
                dpRequestPersistService::revertRequestAnalyserError
                )
        );
\end{lstlisting}

\subsection{Komunikační objekt a využití stažené stránky}
Nejprve je třeba popsat změnu komunikační třídy \textit{DataProviderRequest}, která byla mírně upravena.
Tato komunikační třída představuje jeden požadavek odeslaný pomocí front a skládá se z jednotlivých základních atributů a fragmentů.
Fragmentem je zde myšleno složitější struktura, například komunikační třída obsahující informace o produktu.
\par
Původní návrh počítal s příznakem označující typ požadavku pro DataProvider. Příznak označoval, zda je obsažena stažená stránka či nikoliv. Stav, kdy požadavek obsahoval stránky však nikdy nenastával z důvodu implementace plánování práce. Jelikož jediný rozdíl těchto dvou typů byl v atributu uchovávající staženou stránku, odstranil jsem ho.
\par
Některé další atributy či fragmenty nemusejí být nastaveny jako produkt nebo šablona. U všech těchto atributů a fragmentů jsem proto provedl změnu u \textit{get} metod, aby vracely kontejner \textit{Optional}. Tím bylo jasně indikovaná možnost, že hodnoty nemusí být obsaženy.
\par
V rámci DataProvider pak pouze stačilo, vytvořit při přístupu k jednomu z těchto atributů nebo fragmentu, dvě možné větvení aplikace.
Například pokud byla stránka obsažena v požadavku, byla vytvořena validní odpověď o stažení obsahující tuto stránku, což je demonstrováno na 
následující ukázce:
\begin{lstlisting}[language=Java, caption={Veřejná metoda třídy \textit{DPDownloaderServiceImpl} zajišťující stažení stránky obsahující detail produktu}]
    /**
     * Downloads requested page and returns {@link DownloaderResponse} object.
     *
     * @param dataProviderRequest the request containing url to be downloaded
     * @return DownloaderResponse encapsulating downloaded data or error
     */
    @Override
    public DownloaderResponse download(DataProviderRequest dataProviderRequest) {
        return dataProviderRequest.getDownloadedPage()
                        .map(x -> new DownloaderResponse(Jsoup.parse(x)))
                        .orElseGet(
                                () -> doDownload(dataProviderRequest)
                        );
    }
\end{lstlisting}
\section{Spojení chyb analyzátoru a vylepšení rozhraní}
Oprava více četnosti chyb a samotného rozhraní je posloupnost několika oprav. 
Bylo již zmíněno odstranění přebytečných výjimek, což zajistilo spouštění všech validací. 
Další krok je změna komunikačního objektu, který nové uchovává všechny chybné validace a přesnější informace
o datech použitých při parsování.
\par
Původní řešení obsahovalo dvě třídy určené pro odpověď, jelikož DataProvider má dvě výstupní fronty, pro validní odpověď a chybu. 
Třída pro validní odpověď je \textit{DataProviderResponse}, pro chybu pak \textit{DataProviderResponse}.
\par
Z důvodu velkého množství podobných atributů, obzvlášť po přidání vyparsovaných hodnot, jsem změnil návrh těchto objektů.
Z \textit{DataProviderResponseError} jsem odstranil společné atributy a jako jeho rodiče jsem zvolil přímo \textit{DataProviderResponse}.
Chybná odpověď tak nově obsahovala i všechny informace co validní odpověď. 
\par
Z hlediska Managera bylo potřeba tyto hodnoty nově uložit, jelikož předtím se ukládali pouze získané ceny. Vytvořil tedy jsem novou tabulku
uchovávající informace o vyparsovaných hodnotách, které mohou být použity v případě zobrazení chyby administrátorovi.
Dále bylo třeba uložit detailní informace o chybách, k čemuž jsem opět vytvořil novou tabulku, která je spojena vazbou 1:n s původní
reprezentací chyby.
\par
Dále už pouze stačilo upravit webové rozhraní, aby odpovídalo změněné databázové struktuře. První změna se týkala samotného zobrazení
informací o chybě. Zde jsem využil nově uložených dat. Administrátor má tak možnost vidět použité hodnoty při analyzování a všechny chyby.
Poslední změna už pouze spočívala v zpracování vstupů od administrátora, kdy bylo potřeba uložit všechny možné příznaky pro 
budoucí analyzování. Přidal jsem pak také možnost přesměrovat administrátora do rozhraní, kde může změnit šablonu pro parsování
stránky, jelikož je možné, že analýza je chybná z důvodu změny ve struktuře stránky.

\newpage

\begin{figure}[H]\centering
 	\includegraphics[width=0.9\textwidth]{resources/analyser-err}
	\caption[Webové rozhraní pro vyřešení chyby analyzátoru po provedení vylepšení]{Ukázka webového rozhraní administrátora po provedených vylepšení. 
	}\label{fig:analyser-error}
\end{figure}

\section{Monitorování}
Na virtuální server jsem nasadil službu DataDog \cite{dataDog}, která po jednoduché instalaci umožňuje sledování běžících služeb
a vytížení serveru. Data jsou odesílány přímo do služby DataDog. Webové rozhraní poté umožňuje sledovat posbírané údaje.
\par
Základní funkcionalita poskytuje pouze informace o využití prostředků a přístup k logům. Službu je však možné rozšířit o velký počet doplňků. Pomocí těch je pak možné sledovat například výsledek sestavení v Jenkins nebo obsah a využití RabbitMQ front.


\section{Získání adres obchodů a příslušných detailů produktů}
Vzhledem pouze k malé možnosti využitelnosti implementované části v modulu Finder, především z důvodu dlouhých metod, které zajišťují
základní stavební kámen tohoto modulu jsem se rozhodl modul Finder rozdělit na dvě části. Část vyhledávající 
na internetových obchodech adresy detailů a na část, která samotné obchody vyhledává.
\par
Implementována byla pouze první část, jelikož hledání samotných obchodů lze nahradit manuálním přidání obchodů na kterých chceme vyhledávat, případně 
využít některý se seznamů internetových obchodů v České republice a ty manuálně vložit do databáze.
\par
Module Finder byl zcela odstraněn a nahrazen modulem novým, nazvaným ProductDetailProvider.
Tento modul zajišťuje hledání detailů produktu, což je dosaženo na základě šablony pro daný e-shop, která obsahuje 
tyto atributy:
\begin{itemize}
\item formát url vyhledávající produkt na obchodu
\item oddělovač slov v url adrese
\item selektory pro výběr url adres vedoucí na detaily produktu
\end{itemize}
Pro samotné vytvoření požadavku je nutná existence částečné šablony, která obsahuje informace jak na obchodě vyhledávat.
Po pokusu nalezení adres se vytvoří chyba pro administrátora, aby specifikoval jak na stránce vyhledávat samotné detaily adres. Webové rozhraní
pro tento proces, bylo vytvořeno již v rámci týmového projektu a bylo tedy využito.


\section{Párování produktu}
Byl navržen proces, který se nejprve pokusí produkt spárovat automaticky, pokud nalezne přímou shodu názvu, EANu nebo modelového čísla.
Shodou je pak myšleno, kdy získaná hodnota je podřetězec toho již uloženého nebo naopak.
\par
Pokud se spárování nepodaří, jsou provedeny heuristiky hledající pravděpodobné shody. K detekci pravděpodobnosti shody jsou pak použity
algoritmy počítající společná slova a nejdelší společný podřetězec. Z množiny těchto možností je pak vytvořena chyba, kterou musí zpracovat administrátor.
\par 
Pro tuto možnost a zpracování bylo poté nutné vytvořit webové rozhraní, které administrátorovi umožňuje jednoduché přiřazení 
adresy k produktu nebo všechny možnosti odmítnout.


\section{Detekce neexistující stránky a nenalezeného produktu}
V případě použití interního vyhledávání byl běžný stav, kdy pro hledanou hodnotu nebyl nalezen žádný produkt, což 
systém zpracoval jako chybu šablony, jelikož struktura stránky šabloně neodpovídala. Podobný případ byl při nalezení adresy detailu, která
ač je obchodem vrácena jako výsledek při hledání, tak neexistuje. I pro tuto možnost byla vytvořena chyba šablony, akorát jiného typu.
\par
V případě vyhledávání na obchodě jsem nejprve zvolil řešení, kdy jsem se pokoušel stránku, kde není žádný výsledek porovnat se stránkou, která
byla na obchodě vrácena pro náhodný a nesmyslný řetězec dlouhé délky. Myšlenka byla, že pokud produkt opravdu neexistuje bude
pro nesmyslné hledání vrácena podobná stránka.
\par
Problém toho řešení se ukázala přílišná odlišnost HTML stažených stránek a specifičnost obchodů. Algoritmus tak fungoval
pouze na malé části obchodů.
\par
Proto jsem zvolil řešení, kdy administrátor má při řešení chyby možnost zadat řetězec značící neexistenci produktu (popř. neexistující stránky detailu produktu). Tento řetězec je poté pro každý obchod specifický a před vytvořením příslušné chyby šablony je nejdříve zkontrolováno, zda
se pouze produkt pouze na obchodě nenachází (popř. stránka neexistuje) a to tak že je vyhledán řetězec na stránce. Pokud na stránce je, pak
se nejedná o chybu šablony.

\section{Více šablon detailů produktu}
Původní návrh počítal s možností, kdy stránka detailu produktu má stejnou strukturu napříč celým obchodem.
Tento předpoklad se však ukázal jako chybný, kdy například v případě slevy je element obsahující cenu odlišný.
\par
Jiná struktura pak způsobila chybu šablony. Z toho důvodu jsem implementoval podporu alternativních šablon, které jsou
použity v případě, že hlavní šablona selže. Uložení této šablony jsem zapracoval do rozhraní administrátora, kdy je třeba
vyřešit chybu šablony detailu. Administrátor má možnost buď původní hlavní šablonu opravit nebo uložit jako alternativní.

\section{Více stejných chyb}
Systém se i po změnách potýkal se stavem, kdy se v administrátorském rozhraní objevilo více chyb šablon nebo analyzátoru.
V původní řešení tento stav nastával v případě, kdy neexistovala šablona pro detail nebo vyhledávání na obchodě, což v případě více požadavků
týkajícího se stejného obchodu, způsobilo vytvoření pro každý požadavek chybu.
\par
Chyby lze však predikovat a v případě neexistující šablony odeslat pouze jeden takový požadavek. Ačkoliv jsem pro tento 
stav upravil plánování práce a zároveň přidal kontrolu, která kontroluje zda není takový požadavek již ve frontě, tak
i přes to se stávalo, že administrátor byl zahlcen chybami. Zahlcení v tomto způsobovala šablona, která přestala fungovat.
\par
Jelikož tento stav nelze predikovat, zvolil jsem možnost, kdy je pouze upraveno webové rozhraní a následné uložení opravené chyby.
Uložení pak způsobí vyřešení i ostatních chyb, které mají stejnou příčinu.
\par
Nejprve jsem upravil webové rozhraní, aby chyby se stejnou příčinou nebyly v seznamu vícekrát ale pouze jednou. Po zpracování
jsem poté přidal algoritmus, který nastaví všechny chyby stejného typu jako vyřešené, čímž odpadá nutnost administrátora všechny vyřešit.

\section{Skladem}
V rámci získávání dat u detailu produktu jsem přidal možnost získávat, zda je produkt skladem. 
\par
Pro úpravu jsem upravil nejdříve rozhraní pro vytváření šablony a strukturu databáze, aby uchovávala atribut u šablony a výsledku parsování.
Poté jsem pouze zajistil, aby byl tento atribut zahrnut v rámci komunikace modulu Manager a DataProvider, kde bylo potřeba zajistit
správné uložení do komunikační třídy, samotné získání hodnoty a korektní uložení do databáze.

\section{Ostatní}
Při realizaci vylepšeních jsem také provedl několik menších změn a oprav, které jsem objevil při vývoji. Jedna ze základních a triviálních
změn byla například oprava \textit{jar} souboru sestavené aplikace, která byla zbytečně veliká. Velikost byla způsobena externími knihovnami,
které byly obsaženy v \textit{jar} vícekrát a to pro každý modul. Oprava pak spočívala pouze v přidání jednoho řádku
do \textit{build.gradle}, který specifikuje strukturu projektu a nastavení sestavení pro Gradle.
\begin{lstlisting}[language=Java, caption={Nastavení sestavení \textit{jar} souboru, aby neduplikoval knihovny na kterých
					jsou moduly závislé.}]
        jar.duplicatesStrategy = DuplicatesStrategy.EXCLUDE
\end{lstlisting}


\chapter{Zhodnocení provedených vylepšení}
V této kapitole se budu nejprve věnovat konečné funkcionalitě systému. V návaznosti na výsledný stav poté popíšu jaké nedostatky jsem v rámci testování objevil.


\section{Funkcionalita}

Nejpodstatnější rozdíl při porovnání starého řešení a nového je samotná funkcionalita, která byla značně rozšířena. Především je možné
využít celý proces hledání informací, kdy stačí administrátorem zadat přes webové rozhraní obchody na kterých chceme hledat
a vyřešit případné chyby.
\par
Po vytvoření kampaně je tak možné sledovat kontinuální běh, který poskytuje požadované výsledky. Jako nevýhoda a hlavní nedostatek
se však ukázal velký důraz na administrátora při řešením prvotních situací, především párování produktů.
\par
Při testování bylo ověřeno, že velké množství obchodů neobsahuje správné nebo odlišené identifikátory produktů. Nejčastější je výskyt pouze jména, které často neodpovídá tomu uloženému.
\par
Z toho důvodu je nutné párování
provést ve velké množstvím případů manuálně. Systém se manuální párování snaží ulehčit rozhraním, nicméně i při malém množstvím produktů
hledaných na více obchodem je počet těchto chyb velmi rozsáhlých. 

\section{Webové rozhraní}
Problém párování by bylo možné pak vylepšit, pokud by systém uchovával více identifikátorů. Především více uložených jmen by pak zátěž na administrátora mohla klesnout. Podpora pro tuto možnost však nebyl implementována, ačkoliv v některých částech byla interní část na tuto možnost
již připravena.
\par
Při testování jsem nalezl nedostatky ve webovém rozhraní, kdy funkčnost rozhraní při opravy chyb šablon nebyl na některých obchodech funkční.
V případě použití rozhraní šablony pro vyhledávání na obchodě, tedy definování jak nalézt případně adresy vedoucí na detaily produktů se
ukázalo, že je šablona obvykle nefunkční. Proto bylo nutné zadávat cestu k elementům manuálně.
\par

\section{Návrh a testy}
Zásadní refaktoring a změna návrhu komunikace tříd velmi pozměnila interní část. Interní část kromě toho, že vyhovuje
více nárokům na požadovanou funkcionalitu, je složena z daleko přehlednějšího a lépe udržovatelného kódu. 
\par
Lepší udržovatelnost byla výrazná především při přidávání vylepšení, kdy tyto změny často byly triviální záležitost a po jejich provedení
bylo zachována původní funkcionalita. Toto dávám za důsledek především lepšího pokrytí testů a dekompozice tříd. Oproti původní řešení narostl počet jednotkových testů ze \textbf{170} na \textbf{492}. Pokrytí pak demonstruje následující vizualizace.

\begin{figure}[h]\centering
 	\includegraphics[width=1.0\textwidth]{resources/cobertura-report-new-1}
 	\includegraphics[width=0.7\textwidth]{resources/cobertura-report-new-2}
	\caption[Pokrytí testy po provedených vylepšení]{Pokrytí testy po provedených vylepšení. Získáno pomocí nástroje Cobertura. Vizualizace
	výsledků byla vytvořena při sestavení na Jenkins s příslušným doplňkem.}\label{fig:cober-new}
\end{figure}

Oproti původnímu řešení, vzrostlo pokrytí zhruba o 20\%. Základní funkcionalita servisních tříd je, až na výjimky testy pokrytá celá.
Zbylé neotestované třídy jsou pak především inicializační třídy front a jejich komunikační rozhraní, které je závislé na jiné běžící službě.
\par
I po provedení těchto změn zůstalo omezení nemožnosti vytvoření více instancí jednotlivých modulů, nově ProductDetailProvider a DataProvider.
Tato změna je však vzhledem k návrhu poměrně triviální, kdy pouze stačí přidat instanční rozhraní jednotlivých modulů, jelikož 
momentálně jsou spouštěny přímo modulem Manager. Následující komunikace pak probíhá pouze přes fronty, tudíž není oddělení nezpůsobí
další komplikace, kromě větší zátěže na nastavení infrastruktury nasazení aplikace na serveru.

\section{Rozhraní administrátora}
Systém se stal z hlediska pro administrátora uživatelsky přívětivější. Při řešení chyb je rozhraní přehlednější a informace o chybách
obsáhlejší, což umožňuje rozhodnutí založené na více faktech. Dále byla také podstatně zrychleno celkové zpracování po odpadnutí nutnosti řešit
každý požadavek, ať už se jedná šablona pro stejný obchod či více chyb analyzátoru.

\chapter{Závěr}



\bibliographystyle{csn690}



\bibliography{mybibliografy}

\appendix
\chapter{Seznam použitých zkratek}
% \printglossaries
\begin{description}
	\item[EAN] European Article Number
	\item[XML] Extensible markup language
	\item[HTML] Hypertext Markup Language
	\item[CSS] Cascading style sheets
	\item[JSON] JavaScript Object Notation
	\item[HTTP] Hypertext Transfer Protocol
	\item[DAO] Data Access Object
	\item[URL] Uniform Resource Locator

\end{description}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% % Tuto kapitolu z výsledné práce ODSTRAŇTE.
% % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% 
% \chapter{Návod k~použití této šablony}
% 
% Tento dokument slouží jako základ pro napsání závěrečné práce na Fakultě informačních technologií ČVUT v~Praze.
% 
% \section{Výběr základu}
% 
% Vyberte si šablonu podle druhu práce (bakalářská, diplomová), jazyka (čeština, angličtina) a kódování (ASCII, \mbox{UTF-8}, \mbox{ISO-8859-2} neboli latin2 a nebo \mbox{Windows-1250}). 
% 
% V~české variantě naleznete šablony v~souborech pojmenovaných ve formátu práce\_kódování.tex. Typ může být:
% \begin{description}
% 	\item[BP] bakalářská práce,
% 	\item[DP] diplomová (magisterská) práce.
% \end{description}
% Kódování, ve kterém chcete psát, může být:
% \begin{description}
% 	\item[UTF-8] kódování Unicode,
% 	\item[ISO-8859-2] latin2,
% 	\item[Windows-1250] znaková sada 1250 Windows.
% \end{description}
% V~případě nejistoty ohledně kódování doporučujeme následující postup:
% \begin{enumerate}
% 	\item Otevřete šablony pro kódování UTF-8 v~editoru prostého textu, který chcete pro psaní práce použít -- pokud můžete texty s~diakritikou normálně přečíst, použijte tuto šablonu.
% 	\item V~opačném případě postupujte dále podle toho, jaký operační systém používáte:
% 	\begin{itemize}
% 		\item v~případě Windows použijte šablonu pro kódování \mbox{Windows-1250},
% 		\item jinak zkuste použít šablonu pro kódování \mbox{ISO-8859-2}.
% 	\end{itemize}
% \end{enumerate}
% 
% 
% V~anglické variantě jsou šablony pojmenované podle typu práce, možnosti jsou:
% \begin{description}
% 	\item[bachelors] bakalářská práce,
% 	\item[masters] diplomová (magisterská) práce.
% \end{description}
% 
% \section{Použití šablony}
% 
% Šablona je určena pro zpracování systémem \LaTeXe{}. Text je možné psát v~textovém editoru jako prostý text, lze však také využít specializovaný editor pro \LaTeX{}, např. Kile.
% 
% Pro získání tisknutelného výstupu z~takto vytvořeného souboru použijte příkaz \verb|pdflatex|, kterému předáte cestu k~souboru jako parametr. Vhodný editor pro \LaTeX{} toto udělá za Vás. \verb|pdfcslatex| ani \verb|cslatex| \emph{nebudou} s~těmito šablonami fungovat.
% 
% Více informací o~použití systému \LaTeX{} najdete např. v~\cite{wikilatex}.
% 
% \subsection{Typografie}
% 
% Při psaní dodržujte typografické konvence zvoleného jazyka. České \uv{uvozovky} zapisujte použitím příkazu \verb|\uv|, kterému v~parametru předáte text, jenž má být v~uvozovkách. Anglické otevírací uvozovky se v~\LaTeX{}u zadávají jako dva zpětné apostrofy, uzavírací uvozovky jako dva apostrofy. Často chybně uváděný symbol "{} (palce) nemá s~uvozovkami nic společného.
% 
% Dále je třeba zabránit zalomení řádky mezi některými slovy, v~češtině např. za jednopísmennými předložkami a spojkami (vyjma \uv{a}). To docílíte vložením pružné nezalomitelné mezery -- znakem \texttt{\textasciitilde}. V~tomto případě to není třeba dělat ručně, lze použít program \verb|vlna|.
% 
% Více o~typografii viz \cite{kobltypo}.
% 
% \subsection{Obrázky}
% 
% Pro umožnění vkládání obrázků je vhodné použít balíček \verb|graphicx|, samotné vložení se provede příkazem \verb|\includegraphics|. Takto je možné vkládat obrázky ve formátu PDF, PNG a JPEG jestliže používáte pdf\LaTeX{} nebo ve formátu EPS jestliže používáte \LaTeX{}. Doporučujeme preferovat vektorové obrázky před rastrovými (vyjma fotografií).
% 
% \subsubsection{Získání vhodného formátu}
% 
% Pro získání vektorových formátů PDF nebo EPS z~jiných lze použít některý z~vektorových grafických editorů. Pro převod rastrového obrázku na vektorový lze použít rasterizaci, kterou mnohé editory zvládají (např. Inkscape). Pro konverze lze použít též nástroje pro dávkové zpracování běžně dodávané s~\LaTeX{}em, např. \verb|epstopdf|.
% 
% \subsubsection{Plovoucí prostředí}
% 
% Příkazem \verb|\includegraphics| lze obrázky vkládat přímo, doporučujeme však použít plovoucí prostředí, konkrétně \verb|figure|. Například obrázek \ref{fig:float} byl vložen tímto způsobem. Vůbec přitom nevadí, když je obrázek umístěn jinde, než bylo původně zamýšleno -- je tomu tak hlavně kvůli dodržení typografických konvencí. Namísto vynucování konkrétní pozice obrázku doporučujeme používat odkazování z~textu (dvojice příkazů \verb|\label| a \verb|\ref|).
% 
% \begin{figure}\centering
% 	\includegraphics[width=0.5\textwidth, angle=30]{cvut-logo-bw}
% 	\caption[Příklad obrázku]{Ukázkový obrázek v~plovoucím prostředí}\label{fig:float}
% \end{figure}
% 
% \subsubsection{Verze obrázků}
% 
% % Gnuplot BW i barevně
% Může se hodit mít více verzí stejného obrázku, např. pro barevný či černobílý tisk a nebo pro prezentaci. S~pomocí některých nástrojů na generování grafiky je to snadné.
% 
% Máte-li například graf vytvořený v programu Gnuplot, můžete jeho černobílou variantu (viz obr. \ref{fig:gnuplot-bw}) vytvořit parametrem \verb|monochrome dashed| příkazu \verb|set term|. Barevnou variantu (viz obr. \ref{fig:gnuplot-col}) vhodnou na prezentace lze vytvořit parametrem \verb|colour solid|.
% 
% \begin{figure}\centering
% 	\includegraphics{gnuplot-bw}
% 	\caption{Černobílá varianta obrázku generovaného programem Gnuplot}\label{fig:gnuplot-bw}
% \end{figure}
% 
% \begin{figure}\centering
% 	\includegraphics{gnuplot-col}
% 	\caption{Barevná varianta obrázku generovaného programem Gnuplot}\label{fig:gnuplot-col}
% \end{figure}
% 
% 
% \subsection{Tabulky}
% 
% Tabulky lze zadávat různě, např. v~prostředí \verb|tabular|, avšak pro jejich vkládání platí to samé, co pro obrázky -- použijte plovoucí prostředí, v~tomto případě \verb|table|. Například tabulka \ref{tab:matematika} byla vložena tímto způsobem.
% 
% \begin{table}\centering
% 	\caption[Příklad tabulky]{Zadávání matematiky}\label{tab:matematika}
% 	\begin{tabular}{|l|l|c|c|}\hline
% 		Typ		& Prostředí		& \LaTeX{}ovská zkratka	& \TeX{}ovská zkratka	\tabularnewline \hline \hline
% 		Text		& \verb|math|		& \verb|\(...\)|	& \verb|$...$|		\tabularnewline \hline
% 		Displayed	& \verb|displaymath|	& \verb|\[...\]|	& \verb|$$...$$|	\tabularnewline \hline
% 	\end{tabular}
% \end{table}
% 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\chapter{Obsah přiloženého CD}

%upravte podle skutecnosti

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{stručný popis obsahu CD}.
		.1 exe\DTcomment{adresář se spustitelnou formou implementace}.
		.1 src.
		.2 impl\DTcomment{zdrojové kódy implementace}.
		.2 thesis\DTcomment{zdrojová forma práce ve formátu \LaTeX{}}.
		.1 text\DTcomment{text práce}.
		.2 thesis.pdf\DTcomment{text práce ve formátu PDF}.
		.2 thesis.ps\DTcomment{text práce ve formátu PS}.
	}
\end{figure}

\end{document}
